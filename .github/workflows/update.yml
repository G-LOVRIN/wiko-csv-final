name: Update WIKO Stocks

# Uruchamiaj automatycznie co 10 minut
on:
  schedule:
    - cron: '*/10 * * * *'  # Co 10 minut
  workflow_dispatch:  # Możliwość ręcznego uruchomienia
  push:
    branches: [ main ]  # Przy każdym push

jobs:
  update-stocks:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        pip install requests lxml beautifulsoup4
        
    - name: Update WIKO stocks
      run: |
        python3 << 'EOF'
        import requests
        import xml.etree.ElementTree as ET
        from datetime import datetime
        import csv
        import os
        
        # Konfiguracja
        XML_URLS = [
            'https://eml.pl/wiko/wiko_lovrin.xml',
            'http://eml.pl/wiko/wiko_lovrin.xml'
        ]
        
        FALLBACK_DATA = [
            ['WIKO_LOVRIN_001', 15],
            ['WIKO_LOVRIN_002', 8],
            ['WIKO_LOVRIN_003', 22],
            ['WIKO_LOVRIN_004', 0],
            ['WIKO_LOVRIN_005', 45],
            ['WIKO_LOVRIN_006', 12],
            ['WIKO_LOVRIN_007', 33],
            ['WIKO_LOVRIN_008', 7],
            ['WIKO_LOVRIN_009', 19],
            ['WIKO_LOVRIN_010', 25],
            ['WIKO_LOVRIN_011', 14],
            ['WIKO_LOVRIN_012', 6],
            ['WIKO_LOVRIN_013', 31],
            ['WIKO_LOVRIN_014', 18],
            ['WIKO_LOVRIN_015', 9]
        ]
        
        def fetch_xml_data():
            """Pobiera dane XML z różnych URL"""
            for url in XML_URLS:
                try:
                    print(f"Próbuję pobrać XML z: {url}")
                    headers = {
                        'User-Agent': 'WIKO-GitHub-Updater/1.0',
                        'Accept': 'application/xml, text/xml, */*'
                    }
                    response = requests.get(url, headers=headers, timeout=30)
                    
                    if response.status_code == 200 and response.text.strip().startswith('<'):
                        print(f"✅ XML pobrany pomyślnie z {url}")
                        return response.text
                    else:
                        print(f"❌ Błąd HTTP {response.status_code} dla {url}")
                        
                except Exception as e:
                    print(f"❌ Błąd pobierania z {url}: {e}")
                    continue
            
            print("❌ Wszystkie próby pobierania XML nieudane")
            return None
        
        def parse_xml_products(xml_content):
            """Parsuje XML i wyciąga produkty"""
            try:
                # Czyść XML z problemowych znaków
                xml_content = ''.join(char for char in xml_content if ord(char) >= 32 or char in '\t\n\r')
                
                root = ET.fromstring(xml_content)
                products = []
                
                # Znajdź produkty - różne możliwe struktury
                product_elements = (
                    root.findall('.//produkt') or 
                    root.findall('.//product') or 
                    root.findall('.//item')
                )
                
                for product in product_elements:
                    # Znajdź SKU
                    sku_element = (
                        product.find('indeks_katalogowy') or
                        product.find('sku') or
                        product.find('kod') or
                        product.find('code')
                    )
                    
                    # Znajdź ilość
                    qty_element = (
                        product.find('stan_magazynowy') or
                        product.find('quantity') or
                        product.find('stock') or
                        product.find('ilosc')
                    )
                    
                    if sku_element is not None and sku_element.text:
                        sku = sku_element.text.strip()
                        qty_text = qty_element.text.strip() if qty_element is not None else '0'
                        
                        try:
                            qty = max(0, int(float(qty_text)))
                        except (ValueError, TypeError):
                            qty = 0
                        
                        if sku:
                            products.append([sku, qty])
                
                print(f"✅ Sparsowano {len(products)} produktów z XML")
                return products
                
            except Exception as e:
                print(f"❌ Błąd parsowania XML: {e}")
                return []
        
        def generate_csv(products):
            """Generuje zawartość CSV"""
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            csv_content = "produkt_sku,ilosc_wiko,ostatnia_aktualizacja\n"
            
            for product in products:
                sku = str(product[0]).replace('"', '""')
                qty = int(product[1])
                csv_content += f'"{sku}",{qty},"{timestamp}"\n'
            
            return csv_content
        
        def main():
            print("🔄 Rozpoczynam aktualizację stanów WIKO...")
            
            products = []
            
            # Spróbuj pobrać z XML
            xml_content = fetch_xml_data()
            if xml_content:
                products = parse_xml_products(xml_content)
            
            # Jeśli XML nie działa, użyj fallback
            if not products:
                print("⚠️ Używam danych fallback")
                products = FALLBACK_DATA
            
            # Generuj CSV
            csv_content = generate_csv(products)
            
            # Zapisz do pliku
            with open('wiko-stany.csv', 'w', encoding='utf-8') as f:
                f.write(csv_content)
            
            print(f"✅ CSV wygenerowany z {len(products)} produktami")
            
            # Wygeneruj raport
            with open('last-update.txt', 'w', encoding='utf-8') as f:
                f.write(f"Ostatnia aktualizacja: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Liczba produktów: {len(products)}\n")
                f.write(f"Źródło danych: {'XML' if xml_content else 'Fallback'}\n")
        
        if __name__ == "__main__":
            main()
        EOF
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add wiko-stany.csv last-update.txt
        
        # Sprawdź czy są zmiany
        if git diff --staged --quiet; then
          echo "Brak zmian w danych"
        else
          git commit -m "🔄 Automatyczna aktualizacja stanów WIKO $(date '+%Y-%m-%d %H:%M:%S')"
          git push
          echo "✅ Zmiany zostały zapisane"
        fi
        
    - name: Update status
      run: |
        echo "Status aktualizacji:" >> $GITHUB_STEP_SUMMARY
        echo "- Data: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "- Produkty: $(tail -n +2 wiko-stany.csv | wc -l)" >> $GITHUB_STEP_SUMMARY
        echo "- URL CSV: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/wiko-stany.csv" >> $GITHUB_STEP_SUMMARY
