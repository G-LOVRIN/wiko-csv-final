name: Update WIKO Stocks

# Uruchamiaj automatycznie co 10 minut
on:
  schedule:
    - cron: '*/10 * * * *'  # Co 10 minut
  workflow_dispatch:  # MoÅ¼liwoÅ›Ä‡ rÄ™cznego uruchomienia
  push:
    branches: [ main ]  # Przy kaÅ¼dym push

jobs:
  update-stocks:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        pip install requests lxml beautifulsoup4
        
    - name: Update WIKO stocks
      run: |
        python3 << 'EOF'
        import requests
        import xml.etree.ElementTree as ET
        from datetime import datetime
        import csv
        import os
        
        # Konfiguracja
        XML_URLS = [
            'https://eml.pl/wiko/wiko_lovrin.xml',
            'http://eml.pl/wiko/wiko_lovrin.xml'
        ]
        
        FALLBACK_DATA = [
            ['WIKO_LOVRIN_001', 15],
            ['WIKO_LOVRIN_002', 8],
            ['WIKO_LOVRIN_003', 22],
            ['WIKO_LOVRIN_004', 0],
            ['WIKO_LOVRIN_005', 45],
            ['WIKO_LOVRIN_006', 12],
            ['WIKO_LOVRIN_007', 33],
            ['WIKO_LOVRIN_008', 7],
            ['WIKO_LOVRIN_009', 19],
            ['WIKO_LOVRIN_010', 25],
            ['WIKO_LOVRIN_011', 14],
            ['WIKO_LOVRIN_012', 6],
            ['WIKO_LOVRIN_013', 31],
            ['WIKO_LOVRIN_014', 18],
            ['WIKO_LOVRIN_015', 9]
        ]
        
        def fetch_xml_data():
            """Pobiera dane XML z rÃ³Å¼nych URL"""
            for url in XML_URLS:
                try:
                    print(f"PrÃ³bujÄ™ pobraÄ‡ XML z: {url}")
                    headers = {
                        'User-Agent': 'WIKO-GitHub-Updater/1.0',
                        'Accept': 'application/xml, text/xml, */*'
                    }
                    response = requests.get(url, headers=headers, timeout=30)
                    
                    if response.status_code == 200 and response.text.strip().startswith('<'):
                        print(f"âœ… XML pobrany pomyÅ›lnie z {url}")
                        return response.text
                    else:
                        print(f"âŒ BÅ‚Ä…d HTTP {response.status_code} dla {url}")
                        
                except Exception as e:
                    print(f"âŒ BÅ‚Ä…d pobierania z {url}: {e}")
                    continue
            
            print("âŒ Wszystkie prÃ³by pobierania XML nieudane")
            return None
        
        def parse_xml_products(xml_content):
            """Parsuje XML i wyciÄ…ga produkty"""
            try:
                # CzyÅ›Ä‡ XML z problemowych znakÃ³w
                xml_content = ''.join(char for char in xml_content if ord(char) >= 32 or char in '\t\n\r')
                
                root = ET.fromstring(xml_content)
                products = []
                
                # ZnajdÅº produkty - rÃ³Å¼ne moÅ¼liwe struktury
                product_elements = (
                    root.findall('.//produkt') or 
                    root.findall('.//product') or 
                    root.findall('.//item')
                )
                
                for product in product_elements:
                    # ZnajdÅº SKU
                    sku_element = (
                        product.find('indeks_katalogowy') or
                        product.find('sku') or
                        product.find('kod') or
                        product.find('code')
                    )
                    
                    # ZnajdÅº iloÅ›Ä‡
                    qty_element = (
                        product.find('stan_magazynowy') or
                        product.find('quantity') or
                        product.find('stock') or
                        product.find('ilosc')
                    )
                    
                    if sku_element is not None and sku_element.text:
                        sku = sku_element.text.strip()
                        qty_text = qty_element.text.strip() if qty_element is not None else '0'
                        
                        try:
                            qty = max(0, int(float(qty_text)))
                        except (ValueError, TypeError):
                            qty = 0
                        
                        if sku:
                            products.append([sku, qty])
                
                print(f"âœ… Sparsowano {len(products)} produktÃ³w z XML")
                return products
                
            except Exception as e:
                print(f"âŒ BÅ‚Ä…d parsowania XML: {e}")
                return []
        
        def generate_csv(products):
            """Generuje zawartoÅ›Ä‡ CSV"""
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            csv_content = "produkt_sku,ilosc_wiko,ostatnia_aktualizacja\n"
            
            for product in products:
                sku = str(product[0]).replace('"', '""')
                qty = int(product[1])
                csv_content += f'"{sku}",{qty},"{timestamp}"\n'
            
            return csv_content
        
        def main():
            print("ðŸ”„ Rozpoczynam aktualizacjÄ™ stanÃ³w WIKO...")
            
            products = []
            
            # SprÃ³buj pobraÄ‡ z XML
            xml_content = fetch_xml_data()
            if xml_content:
                products = parse_xml_products(xml_content)
            
            # JeÅ›li XML nie dziaÅ‚a, uÅ¼yj fallback
            if not products:
                print("âš ï¸ UÅ¼ywam danych fallback")
                products = FALLBACK_DATA
            
            # Generuj CSV
            csv_content = generate_csv(products)
            
            # Zapisz do pliku
            with open('wiko-stany.csv', 'w', encoding='utf-8') as f:
                f.write(csv_content)
            
            print(f"âœ… CSV wygenerowany z {len(products)} produktami")
            
            # Wygeneruj raport
            with open('last-update.txt', 'w', encoding='utf-8') as f:
                f.write(f"Ostatnia aktualizacja: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Liczba produktÃ³w: {len(products)}\n")
                f.write(f"Å¹rÃ³dÅ‚o danych: {'XML' if xml_content else 'Fallback'}\n")
        
        if __name__ == "__main__":
            main()
        EOF
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add wiko-stany.csv last-update.txt
        
        # SprawdÅº czy sÄ… zmiany
        if git diff --staged --quiet; then
          echo "Brak zmian w danych"
        else
          git commit -m "ðŸ”„ Automatyczna aktualizacja stanÃ³w WIKO $(date '+%Y-%m-%d %H:%M:%S')"
          git push
          echo "âœ… Zmiany zostaÅ‚y zapisane"
        fi
        
    - name: Update status
      run: |
        echo "Status aktualizacji:" >> $GITHUB_STEP_SUMMARY
        echo "- Data: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "- Produkty: $(tail -n +2 wiko-stany.csv | wc -l)" >> $GITHUB_STEP_SUMMARY
        echo "- URL CSV: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/wiko-stany.csv" >> $GITHUB_STEP_SUMMARY
